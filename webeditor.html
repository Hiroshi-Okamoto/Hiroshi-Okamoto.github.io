<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Local Code Editor (Fixed V7)</title>
    
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- Babel -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- PrismJS (Syntax Highlighter) -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-css.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-markup.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-markdown.min.js"></script>

    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;700&family=Roboto+Mono:wght@400&display=swap" rel="stylesheet">

    <style>
        body {
            font-family: 'Noto Sans JP', sans-serif;
            background-color: #1e1e1e;
            color: #d4d4d4;
            overflow: hidden;
        }

        /* * [重要] 共通スタイル設定 
         * テキスト計測の精度を保つため、フォント設定はJS側と一致させる必要があります。
         */
        .editor-container textarea.editor-common-style,
        .editor-container pre.editor-common-style,
        .editor-container pre.editor-common-style code,
        .editor-container pre.editor-common-style span {
            font-family: 'Roboto Mono', 'Noto Sans JP', monospace !important;
            font-size: 14px !important;
            line-height: 24px !important;
            font-weight: 400 !important;
            letter-spacing: 0px !important;
            
            margin: 0 !important;
            border: 0 !important;
            outline: none !important;
            box-sizing: border-box !important;
            
            white-space: pre !important;
            overflow-wrap: normal !important;
            word-break: normal !important;
            
            tab-size: 4 !important;
            -moz-tab-size: 4 !important;
        }

        /* Paddingの指定 */
        .editor-container textarea.editor-common-style,
        .editor-container pre.editor-common-style {
            padding: 10px !important;
        }

        /* Syntax Highlight Colors */
        .token.comment,
        .token.prolog,
        .token.doctype,
        .token.cdata { color: #6a9955; }
        
        /* Invisible Characters */
        .invis-space { color: #4d4d4d; }
        .invis-tab { color: #4d4d4d; }
        .invis-eol { color: #606060; font-size: 0.8em; user-select: none; }

        /* Layout */
        .editor-container {
            position: relative;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #1e1e1e;
        }

        /* Layer 1: Highlight */
        .editor-pre {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            z-index: 1;
            background: #1e1e1e;
            pointer-events: none;
            overflow: hidden;
        }

        /* Layer 2: Input */
        .editor-textarea {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            z-index: 10;
            background: transparent;
            color: transparent;
            caret-color: #ffffff;
            resize: none;
            overflow: auto;
        }
        
        .editor-textarea::selection {
            background: rgba(38, 79, 120, 0.5);
            color: transparent;
        }

        /* Scrollbar */
        ::-webkit-scrollbar { width: 14px; height: 14px; }
        ::-webkit-scrollbar-track { background: #1e1e1e; }
        ::-webkit-scrollbar-thumb { background: #424242; border: 3px solid #1e1e1e; border-radius: 7px; }
        ::-webkit-scrollbar-thumb:hover { background: #4f4f4f; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useRef, useEffect, useMemo, useCallback } = React;

        // --- Utils ---
        const generateId = () => Date.now().toString(36) + Math.random().toString(36).substr(2);

        const detectLanguage = (name) => {
            if (name.endsWith('.py')) return 'python';
            if (name.endsWith('.js') || name.endsWith('.jsx') || name.endsWith('.ts')) return 'javascript';
            if (name.endsWith('.html')) return 'markup';
            if (name.endsWith('.css')) return 'css';
            if (name.endsWith('.md') || name.endsWith('.markdown')) return 'markdown';
            return 'plain';
        };

        const detectLineEnding = (content) => {
            if (content.indexOf('\r\n') !== -1) return "CRLF";
            if (content.indexOf('\r') !== -1 && content.indexOf('\n') === -1) return "CR";
            return "LF";
        };

        // --- Text Width Measurement Helper ---
        // テキスト幅計測用のContextを再利用
        const widthContext = document.createElement('canvas').getContext('2d');
        // CSSと一致させること
        widthContext.font = "400 14px 'Roboto Mono', 'Noto Sans JP', monospace";

        const measureTextWidth = (text) => {
            // Tab文字はCanvasのmeasureTextで正しく計算されないため、スペース4つに置換して概算
            const expandedText = text.replace(/\t/g, '    '); 
            return widthContext.measureText(expandedText).width;
        };

        // --- Scroll Sync Helper ---
        const LINE_HEIGHT = 24;
        const PADDING_TOP = 10;
        const PADDING_LEFT = 10;

        const scrollToCursor = (textarea, pos) => {
            if (!textarea) return;
            
            // --- 縦方向の計算 ---
            const value = textarea.value;
            // カーソルまでのテキストを行単位で分割
            const textUntilCursor = value.substring(0, pos);
            const lines = textUntilCursor.split('\n');
            const lineIndex = lines.length - 1;
            
            const cursorTop = PADDING_TOP + (lineIndex * LINE_HEIGHT);
            const cursorBottom = cursorTop + LINE_HEIGHT;
            
            const viewTop = textarea.scrollTop;
            const viewHeight = textarea.clientHeight;
            const viewBottom = viewTop + viewHeight;
            
            if (cursorTop < viewTop) {
                textarea.scrollTop = cursorTop - PADDING_TOP;
            } else if (cursorBottom > viewBottom) {
                textarea.scrollTop = cursorBottom - viewHeight + PADDING_TOP;
            }

            // --- 横方向の計算 (追加) ---
            // 現在の行の行頭からカーソルまでのテキストを取得
            const textInLineBeforeCursor = lines[lineIndex];
            
            // テキスト幅を計測して、カーソルのX座標（左端からのピクセル数）を算出
            const textWidth = measureTextWidth(textInLineBeforeCursor);
            const cursorLeft = PADDING_LEFT + textWidth;
            const cursorRight = cursorLeft + 2; // カーソル幅分少し余裕を見る

            const viewLeft = textarea.scrollLeft;
            const viewWidth = textarea.clientWidth;
            const viewRight = viewLeft + viewWidth;

            const hScrollPadding = 30; // 余裕を持ってスクロールさせる

            if (cursorLeft < viewLeft) {
                textarea.scrollLeft = Math.max(0, cursorLeft - hScrollPadding);
            } else if (cursorRight > viewRight) {
                textarea.scrollLeft = cursorRight - viewWidth + hScrollPadding;
            }
        };

        // --- Editor Pane Component ---
        const EditorPane = ({ file, updateFile }) => {
            const textareaRef = useRef(null);
            const preRef = useRef(null);

            const { content, language, lineEnding } = file;

            const handleScroll = () => {
                if (textareaRef.current && preRef.current) {
                    preRef.current.scrollTop = textareaRef.current.scrollTop;
                    preRef.current.scrollLeft = textareaRef.current.scrollLeft;
                }
            };

            const setContent = (newContent) => updateFile({ ...file, content: newContent });

            const handleKeyDown = (e) => {
                const el = e.target;
                const value = el.value;
                const start = el.selectionStart;

                // Emacs Keybinds & Shortcut Prevention
                if (e.ctrlKey && !e.altKey && !e.metaKey) {
                    const k = e.key.toLowerCase();
                    const emacsKeys = ['f', 'b', 'n', 'p', 'a', 'e', 'd', 'k', 'h'];
                    
                    if (emacsKeys.includes(k)) {
                        e.preventDefault();
                        e.stopPropagation();

                        const getLineStart = (pos) => value.lastIndexOf('\n', pos - 1) + 1;
                        const getLineEnd = (pos) => {
                            const idx = value.indexOf('\n', pos);
                            return idx === -1 ? value.length : idx;
                        };

                        let newPos = start;

                        switch (k) {
                            case 'f': // Forward
                                newPos = start + 1; 
                                break;
                            case 'b': // Backward
                                newPos = Math.max(0, start - 1); 
                                break;
                            case 'n': { // Next line
                                const currLineStart = getLineStart(start);
                                const col = start - currLineStart;
                                const currLineEnd = getLineEnd(start);
                                if (currLineEnd < value.length) {
                                    const nextLineStart = currLineEnd + 1;
                                    const nextLineEnd = getLineEnd(nextLineStart);
                                    newPos = nextLineStart + Math.min(col, nextLineEnd - nextLineStart);
                                }
                                break;
                            }
                            case 'p': { // Prev line
                                const currLineStart = getLineStart(start);
                                const col = start - currLineStart;
                                if (currLineStart > 0) {
                                    const prevLineEnd = currLineStart - 1;
                                    const prevLineStart = getLineStart(prevLineEnd);
                                    newPos = prevLineStart + Math.min(col, prevLineEnd - prevLineStart);
                                }
                                break;
                            }
                            case 'a': // Start of line
                                newPos = getLineStart(start); 
                                break;
                            case 'e': // End of line
                                newPos = getLineEnd(start); 
                                break;
                            case 'd': // Delete char
                                if (start < value.length) {
                                    const nextVal = value.slice(0, start) + value.slice(start + 1);
                                    setContent(nextVal);
                                    setTimeout(() => scrollToCursor(el, start), 0);
                                    return; 
                                }
                                break;
                            case 'k': // Kill line
                                {
                                    const lineEnd = getLineEnd(start);
                                    const nextVal = (start === lineEnd && start < value.length)
                                        ? value.slice(0, start) + value.slice(start + 1)
                                        : value.slice(0, start) + value.slice(lineEnd);
                                    setContent(nextVal);
                                    setTimeout(() => scrollToCursor(el, start), 0);
                                    return;
                                }
                            case 'h': // Backspace
                                if (start > 0) {
                                    const nextVal = value.slice(0, start - 1) + value.slice(start);
                                    setContent(nextVal);
                                    setTimeout(() => {
                                        el.setSelectionRange(start - 1, start - 1);
                                        scrollToCursor(el, start - 1);
                                    }, 0);
                                    return;
                                }
                                break;
                        }

                        // カーソル移動実行とスクロール追従
                        if (newPos !== start) {
                            el.setSelectionRange(newPos, newPos);
                            scrollToCursor(el, newPos);
                        }
                    }
                }

                if (e.key === 'Tab') {
                    e.preventDefault();
                    const newVal = value.substring(0, start) + '\t' + value.substring(el.selectionEnd);
                    setContent(newVal);
                    setTimeout(() => {
                        el.setSelectionRange(start + 1, start + 1);
                        scrollToCursor(el, start + 1);
                    }, 0);
                }
            };

            const handlePaste = (e) => {
                e.preventDefault();
                let text = (e.clipboardData || window.clipboardData).getData('text/plain');
                if (text) {
                    text = text.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
                }
                const el = e.target;
                const start = el.selectionStart;
                const end = el.selectionEnd;
                const newVal = content.substring(0, start) + text + content.substring(end);
                setContent(newVal);
                setTimeout(() => {
                    const newCursor = start + text.length;
                    el.setSelectionRange(newCursor, newCursor);
                    scrollToCursor(el, newCursor);
                }, 0);
            };

            const highlightedCode = useMemo(() => {
                let html;
                const grammar = Prism.languages[language] || Prism.languages.plain;
                html = Prism.highlight(content, grammar, language);

                const eolSymbol = { 'LF': '↓', 'CR': '␍', 'CRLF': '↵' }[lineEnding] || '↓';
                const eolHtml = `<span class="invis-eol">${eolSymbol}</span>`;
                const spaceHtml = '<span class="invis-space">·</span>';
                const tabHtml = '<span class="invis-tab">→   </span>';

                return html.replace(/<[^>]*>|[^<]+/g, (match) => {
                    if (match.startsWith('<')) return match;
                    return match.replace(/ /g, spaceHtml).replace(/\t/g, tabHtml);
                }).replace(/\n/g, eolHtml + '\n');
            }, [content, language, lineEnding]);

            useEffect(() => {
                if(textareaRef.current && preRef.current) {
                   preRef.current.scrollTop = 0;
                   preRef.current.scrollLeft = 0;
                   textareaRef.current.scrollTop = 0;
                   textareaRef.current.scrollLeft = 0;
                }
            }, [file.id]);

            return (
                <div className="editor-container group">
                    <pre ref={preRef} className="editor-pre editor-common-style">
                        <code dangerouslySetInnerHTML={{ __html: highlightedCode + (content.endsWith('\n') ? '' : '') }} />
                    </pre>
                    <textarea
                        ref={textareaRef}
                        value={content}
                        onChange={(e) => setContent(e.target.value)}
                        onScroll={handleScroll}
                        onKeyDown={handleKeyDown}
                        onPaste={handlePaste}
                        className="editor-textarea editor-common-style"
                        spellCheck="false"
                        autoCapitalize="off"
                        autoComplete="off"
                        autoCorrect="off"
                    />
                </div>
            );
        };

        // --- Sidebar Item ---
        const FileListItem = ({ file, isActive, onClick, onClose }) => {
            return (
                <div 
                    onClick={onClick}
                    className={`flex items-center justify-between px-3 py-2 text-sm cursor-pointer border-l-2 transition-colors group
                        ${isActive 
                            ? 'bg-[#37373d] text-white border-blue-500' 
                            : 'bg-transparent text-[#969696] border-transparent hover:bg-[#2a2d2e] hover:text-gray-200'}`}
                >
                    <div className="flex items-center gap-2 overflow-hidden">
                        <span className="opacity-70 text-xs font-mono w-4 flex-shrink-0">
                           {file.language === 'plain' ? 'TXT' : file.language.slice(0,2).toUpperCase()}
                        </span>
                        <span className="truncate">{file.name}</span>
                    </div>
                    <button 
                        onClick={(e) => { e.stopPropagation(); onClose(); }}
                        className={`opacity-0 group-hover:opacity-100 hover:text-white p-1 rounded hover:bg-[#4d4d4d] ${isActive ? 'opacity-100' : ''}`}
                    >
                        <svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
                    </button>
                </div>
            );
        };

        // --- Main App ---
        const App = () => {
            const [files, setFiles] = useState([
                { id: '1', name: 'readme.md', content: '# Fixed Editor V7\n\n- Horizontal scroll sync on cursor move\n- Fixed Cursor vertical alignment', language: 'markdown', lineEnding: 'LF' }
            ]);
            const [activeId, setActiveId] = useState('1');
            const [isSplit, setIsSplit] = useState(false);
            const [msg, setMsg] = useState("");
            const [sidebarWidth, setSidebarWidth] = useState(200);

            const activeFile = files.find(f => f.id === activeId) || files[0];

            const showMessage = (text) => {
                setMsg(text);
                setTimeout(() => setMsg(""), 3000);
            };

            const updateActiveFile = (updatedFile) => {
                setFiles(files.map(f => f.id === updatedFile.id ? updatedFile : f));
            };

            const createNewFile = () => {
                const newId = generateId();
                const newFile = { id: newId, name: 'untitled.txt', content: '', language: 'plain', lineEnding: 'LF' };
                setFiles([...files, newFile]);
                setActiveId(newId);
            };

            const closeFile = (id) => {
                const newFiles = files.filter(f => f.id !== id);
                if (newFiles.length === 0) {
                    const newId = generateId();
                    setFiles([{ id: newId, name: 'untitled.txt', content: '', language: 'plain', lineEnding: 'LF' }]);
                    setActiveId(newId);
                } else {
                    setFiles(newFiles);
                    if (id === activeId) {
                        setActiveId(newFiles[newFiles.length - 1].id);
                    }
                }
            };

            const importFiles = (fileList) => {
                if (!fileList || fileList.length === 0) return;

                Array.from(fileList).forEach(file => {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const raw = e.target.result;
                        const lineEnding = detectLineEnding(raw);
                        const content = raw.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
                        const newFile = {
                            id: generateId(),
                            name: file.name,
                            content,
                            language: detectLanguage(file.name),
                            lineEnding
                        };
                        setFiles(prev => [...prev, newFile]);
                        setActiveId(newFile.id);
                    };
                    reader.readAsText(file);
                });
                showMessage(`${fileList.length} files imported`);
            };

            const handleDownload = () => {
                if (!activeFile) return;
                let raw = activeFile.content;
                if (activeFile.lineEnding === 'CRLF') raw = raw.replace(/\n/g, '\r\n');
                else if (activeFile.lineEnding === 'CR') raw = raw.replace(/\n/g, '\r');

                const blob = new Blob([raw], { type: "text/plain" });
                const url = URL.createObjectURL(blob);
                const a = document.createElement("a");
                a.href = url;
                a.download = activeFile.name;
                a.click();
                URL.revokeObjectURL(url);
                showMessage(`Saved ${activeFile.name}`);
            };

            const handleDrop = (e) => {
                e.preventDefault();
                importFiles(e.dataTransfer.files);
            };

            return (
                <div 
                    className="flex h-screen w-screen bg-[#1e1e1e] text-[#cccccc]" 
                    onDragOver={e => e.preventDefault()} 
                    onDrop={handleDrop}
                >
                    {/* Sidebar */}
                    <aside 
                        className="bg-[#252526] flex flex-col border-r border-[#1e1e1e] flex-shrink-0 relative"
                        style={{ width: sidebarWidth }}
                    >
                        <div className="h-9 px-3 flex items-center justify-between text-xs font-bold text-[#bbbbbb] uppercase tracking-wider bg-[#2d2d2d]">
                            <span>Explorer</span>
                            <div className="flex gap-1">
                                <button onClick={createNewFile} className="hover:text-white" title="New File">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="12" y1="18" x2="12" y2="12"></line><line x1="9" y1="15" x2="15" y2="15"></line></svg>
                                </button>
                                <label className="hover:text-white cursor-pointer" title="Import File">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line></svg>
                                    <input type="file" multiple className="hidden" onChange={e => importFiles(e.target.files)} />
                                </label>
                            </div>
                        </div>
                        
                        <div className="flex-1 overflow-y-auto py-1">
                            {files.map(f => (
                                <FileListItem 
                                    key={f.id} 
                                    file={f} 
                                    isActive={f.id === activeId} 
                                    onClick={() => setActiveId(f.id)}
                                    onClose={() => closeFile(f.id)}
                                />
                            ))}
                        </div>
                    </aside>

                    {/* Main Content */}
                    <div className="flex-1 flex flex-col min-w-0">
                        <header className="h-10 bg-[#2d2d2d] flex items-center justify-between px-4 border-b border-[#1e1e1e]">
                            <div className="flex items-center gap-3 overflow-hidden">
                                {activeFile && (
                                    <>
                                        <input 
                                            type="text" 
                                            value={activeFile.name}
                                            onChange={(e) => updateActiveFile({ ...activeFile, name: e.target.value, language: detectLanguage(e.target.value) })}
                                            className="bg-transparent text-gray-200 text-sm font-medium focus:bg-[#3c3c3c] focus:outline-none px-1 rounded truncate min-w-[50px]"
                                        />
                                        <span className="text-xs text-gray-500 hidden sm:inline">
                                            {activeFile.language} • {activeFile.content.length} chars
                                        </span>
                                    </>
                                )}
                            </div>

                            <div className="flex items-center gap-2">
                                {msg && <span className="text-green-400 text-xs mr-2 animate-pulse">{msg}</span>}
                                
                                {activeFile && (
                                    <>
                                        <div className="flex items-center text-xs bg-[#3c3c3c] rounded border border-[#555] overflow-hidden mr-2">
                                            {['LF', 'CRLF', 'CR'].map(mode => (
                                                <button 
                                                    key={mode}
                                                    onClick={() => updateActiveFile({ ...activeFile, lineEnding: mode })} 
                                                    className={`px-2 py-1 ${activeFile.lineEnding===mode ? 'bg-[#007acc] text-white' : 'text-gray-400 hover:bg-[#4d4d4d]'}`}
                                                >
                                                    {mode}
                                                </button>
                                            ))}
                                        </div>

                                        <button 
                                            onClick={() => setIsSplit(!isSplit)}
                                            className={`p-1.5 rounded transition-colors ${isSplit ? 'bg-[#007acc] text-white' : 'bg-[#3c3c3c] text-gray-300 hover:bg-[#4d4d4d]'}`}
                                            title="Split View"
                                        >
                                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect x="2" y="3" width="20" height="18" rx="2" ry="2"></rect><line x1="12" y1="3" x2="12" y2="21"></line></svg>
                                        </button>

                                        <button 
                                            onClick={handleDownload}
                                            className="bg-green-700 hover:bg-green-600 text-white p-1.5 rounded transition-colors ml-1"
                                            title="Save File"
                                        >
                                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path><polyline points="17 21 17 13 7 13 7 21"></polyline><polyline points="7 3 7 8 15 8"></polyline></svg>
                                        </button>
                                    </>
                                )}
                            </div>
                        </header>

                        <main className="flex-1 flex overflow-hidden relative bg-[#1e1e1e]">
                            {activeFile ? (
                                isSplit ? (
                                    <>
                                        <div className="w-1/2 h-full border-r border-[#333]">
                                            <EditorPane file={activeFile} updateFile={updateActiveFile} />
                                        </div>
                                        <div className="w-1/2 h-full">
                                            <EditorPane file={activeFile} updateFile={updateActiveFile} />
                                        </div>
                                    </>
                                ) : (
                                    <div className="w-full h-full">
                                        <EditorPane file={activeFile} updateFile={updateActiveFile} />
                                    </div>
                                )
                            ) : (
                                <div className="w-full h-full flex items-center justify-center text-gray-500">
                                    No file open
                                </div>
                            )}
                        </main>
                        
                        <footer className="h-6 bg-[#007acc] text-white text-xs flex items-center px-4 justify-between select-none">
                             <div className="flex gap-4">
                                {activeFile && (
                                    <>
                                        <span>Ln {activeFile.content.split('\n').length}</span>
                                        <span>{activeFile.language.toUpperCase()}</span>
                                    </>
                                )}
                            </div>
                            <div className="flex gap-4">
                                <span>UTF-8</span>
                            </div>
                        </footer>
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
