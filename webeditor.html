<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Local Code Editor (Fixed V3)</title>
    
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- Babel -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- PrismJS (Syntax Highlighter) -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-css.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-markup.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-markdown.min.js"></script>

    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;700&family=Roboto+Mono:wght@400;500&display=swap" rel="stylesheet">

    <style>
        body {
            font-family: 'Noto Sans JP', sans-serif;
            background-color: #1e1e1e;
            color: #d4d4d4;
            overflow: hidden;
        }
        
        /* フォントと行送りの固定化（行ズレ防止） */
        .editor-font {
            font-family: 'Roboto Mono', Consolas, 'Courier New', monospace;
            font-size: 14px;
            line-height: 21px; /* Fixed pixel height prevents vertical drift */
            tab-size: 4;
        }

        /* Invisible Characters */
        .invis-space { color: #4d4d4d; }
        .invis-tab { color: #4d4d4d; }
        .invis-eol { color: #606060; font-size: 0.8em; margin-left: 2px; user-select: none; }

        /* Overlay Layout */
        .editor-container {
            position: relative;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #1e1e1e;
        }

        .editor-textarea {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            z-index: 10; margin: 0; 
            padding: 10px;
            border: none; outline: none; resize: none;
            background: transparent; color: transparent;
            caret-color: #fff; white-space: pre; overflow: auto;
        }
        .editor-textarea::selection {
            background: rgba(255, 255, 255, 0.1);
            color: transparent;
        }

        .editor-pre {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            z-index: 1; margin: 0; 
            padding: 10px;
            border: none; background: #1e1e1e;
            pointer-events: none; white-space: pre; overflow: hidden;
        }
        
        .editor-pre code { 
            font-family: inherit !important; 
            line-height: inherit !important;
        }

        ::-webkit-scrollbar { width: 10px; height: 10px; }
        ::-webkit-scrollbar-track { background: #252526; }
        ::-webkit-scrollbar-thumb { background: #444; border-radius: 5px; }
        ::-webkit-scrollbar-thumb:hover { background: #555; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useRef, useEffect, useMemo, useCallback } = React;

        // --- Utils ---
        const generateId = () => Date.now().toString(36) + Math.random().toString(36).substr(2);

        const detectLanguage = (name) => {
            if (name.endsWith('.py')) return 'python';
            if (name.endsWith('.js') || name.endsWith('.jsx') || name.endsWith('.ts')) return 'javascript';
            if (name.endsWith('.html')) return 'markup';
            if (name.endsWith('.css')) return 'css';
            if (name.endsWith('.md') || name.endsWith('.markdown')) return 'markdown';
            return 'plain';
        };

        const detectLineEnding = (content) => {
            if (content.indexOf('\r\n') !== -1) return "CRLF";
            if (content.indexOf('\r') !== -1 && content.indexOf('\n') === -1) return "CR";
            return "LF";
        };

        // --- Scroll Helper ---
        // カーソル位置に合わせてスクロールする関数
        const scrollToCursor = (textarea, pos) => {
            if (!textarea) return;
            
            const value = textarea.value;
            // カーソル位置までの行数を数える
            const lineIndex = value.substring(0, pos).split('\n').length - 1;
            
            // CSSと一致させる必要がある定数
            const lineHeight = 21; 
            const paddingTop = 10; 
            
            // カーソルのY座標範囲
            const cursorTop = paddingTop + (lineIndex * lineHeight);
            const cursorBottom = cursorTop + lineHeight;
            
            // 現在の表示領域
            const viewTop = textarea.scrollTop;
            const viewBottom = viewTop + textarea.clientHeight;
            
            // 範囲外ならスクロール
            if (cursorTop < viewTop) {
                textarea.scrollTop = cursorTop - paddingTop;
            } else if (cursorBottom > viewBottom) {
                textarea.scrollTop = cursorBottom - textarea.clientHeight + paddingTop; 
            }
        };

        // --- Emacs Keybinding Logic ---
        const handleEmacsKeys = (e, value, setContent) => {
            if (!e.ctrlKey || e.altKey || e.metaKey) return;
            if (['c', 'v', 'x', 'z', 'y'].includes(e.key.toLowerCase())) return;

            const targetKeys = ['f', 'b', 'n', 'p', 'a', 'e', 'd', 'k', 'h'];
            if (targetKeys.includes(e.key.toLowerCase())) {
                e.preventDefault();
            } else {
                return;
            }

            const el = e.target;
            const start = el.selectionStart;
            
            const getLineStart = (pos) => value.lastIndexOf('\n', pos - 1) + 1;
            const getLineEnd = (pos) => {
                const idx = value.indexOf('\n', pos);
                return idx === -1 ? value.length : idx;
            };

            let newPos = start;
            let shouldUpdateScroll = false;

            switch (e.key.toLowerCase()) {
                case 'f': 
                    newPos = start + 1;
                    el.setSelectionRange(newPos, newPos);
                    shouldUpdateScroll = true;
                    break;
                case 'b': 
                    newPos = Math.max(0, start - 1);
                    el.setSelectionRange(newPos, newPos);
                    shouldUpdateScroll = true;
                    break;
                case 'n': { 
                    const currLineStart = getLineStart(start);
                    const col = start - currLineStart;
                    const currLineEnd = getLineEnd(start);
                    if (currLineEnd < value.length) {
                        const nextLineStart = currLineEnd + 1;
                        const nextLineEnd = getLineEnd(nextLineStart);
                        newPos = nextLineStart + Math.min(col, nextLineEnd - nextLineStart);
                        el.setSelectionRange(newPos, newPos);
                        shouldUpdateScroll = true;
                    }
                    break;
                }
                case 'p': { 
                    const currLineStart = getLineStart(start);
                    const col = start - currLineStart;
                    if (currLineStart > 0) {
                        const prevLineEnd = currLineStart - 1;
                        const prevLineStart = getLineStart(prevLineEnd);
                        newPos = prevLineStart + Math.min(col, prevLineEnd - prevLineStart);
                        el.setSelectionRange(newPos, newPos);
                        shouldUpdateScroll = true;
                    }
                    break;
                }
                case 'a': 
                    newPos = getLineStart(start);
                    el.setSelectionRange(newPos, newPos); 
                    shouldUpdateScroll = true;
                    break;
                case 'e': 
                    newPos = getLineEnd(start);
                    el.setSelectionRange(newPos, newPos); 
                    shouldUpdateScroll = true;
                    break;
                case 'd': 
                    if (start < value.length) { 
                        setContent(value.slice(0, start) + value.slice(start + 1)); 
                        setTimeout(() => {
                            el.setSelectionRange(start, start);
                            scrollToCursor(el, start);
                        }, 0); 
                    } 
                    break;
                case 'k': {
                    const lineEnd = getLineEnd(start);
                    if (start === lineEnd && start < value.length) {
                        setContent(value.slice(0, start) + value.slice(start + 1));
                    } else {
                        setContent(value.slice(0, start) + value.slice(lineEnd));
                    }
                    setTimeout(() => {
                        el.setSelectionRange(start, start);
                        scrollToCursor(el, start);
                    }, 0);
                    break;
                }
                case 'h': 
                    if (start > 0) { 
                        setContent(value.slice(0, start - 1) + value.slice(start)); 
                        setTimeout(() => {
                            el.setSelectionRange(start - 1, start - 1);
                            scrollToCursor(el, start - 1);
                        }, 0); 
                    } 
                    break;
            }

            // 移動のみの操作の場合は、ここでスクロールを実行
            if (shouldUpdateScroll) {
                scrollToCursor(el, newPos);
            }
        };

        // --- Single Editor Pane ---
        const EditorPane = ({ file, updateFile }) => {
            const textareaRef = useRef(null);
            const preRef = useRef(null);

            const { content, language, lineEnding } = file;

            const handleScroll = () => {
                if (textareaRef.current && preRef.current) {
                    preRef.current.scrollTop = textareaRef.current.scrollTop;
                    preRef.current.scrollLeft = textareaRef.current.scrollLeft;
                }
            };

            const setContent = (newContent) => updateFile({ ...file, content: newContent });

            const handleKeyDown = (e) => {
                if (e.key === 'Tab') {
                    e.preventDefault();
                    const el = e.target;
                    const start = el.selectionStart;
                    const end = el.selectionEnd;
                    const newVal = content.substring(0, start) + '\t' + content.substring(end);
                    setContent(newVal);
                    setTimeout(() => {
                        el.setSelectionRange(start + 1, start + 1);
                        scrollToCursor(el, start + 1);
                    }, 0);
                    return;
                }
                handleEmacsKeys(e, content, setContent);
            };

            const handlePaste = (e) => {
                e.preventDefault();
                let text = (e.clipboardData || window.clipboardData).getData('text/plain');
                if (text) {
                    text = text.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
                }
                const el = e.target;
                const start = el.selectionStart;
                const end = el.selectionEnd;
                const newVal = content.substring(0, start) + text + content.substring(end);
                setContent(newVal);
                setTimeout(() => {
                    el.setSelectionRange(start + text.length, start + text.length);
                    scrollToCursor(el, start + text.length);
                }, 0);
            };

            const highlightedCode = useMemo(() => {
                let html;
                const grammar = Prism.languages[language] || Prism.languages.plain;
                html = Prism.highlight(content, grammar, language);

                const eolSymbol = { 'LF': '↓', 'CR': '␍', 'CRLF': '↵' }[lineEnding] || '↓';
                const eolHtml = `<span class="invis-eol">${eolSymbol}</span>`;
                const spaceHtml = '<span class="invis-space">·</span>';
                const tabHtml = '<span class="invis-tab">→   </span>';

                return html.replace(/<[^>]*>|[^<]+/g, (match) => {
                    if (match.startsWith('<')) return match;
                    return match.replace(/ /g, spaceHtml).replace(/\t/g, tabHtml);
                }).replace(/\n/g, eolHtml + '\n');
            }, [content, language, lineEnding]);

            useEffect(() => {
                if(textareaRef.current && preRef.current) {
                   preRef.current.scrollTop = 0;
                   preRef.current.scrollLeft = 0;
                   textareaRef.current.scrollTop = 0;
                   textareaRef.current.scrollLeft = 0;
                }
            }, [file.id]);

            return (
                <div className="editor-container group">
                    <pre ref={preRef} className="editor-pre editor-font">
                        <code dangerouslySetInnerHTML={{ __html: highlightedCode + (content.endsWith('\n') ? '' : '') }} />
                    </pre>
                    <textarea
                        ref={textareaRef}
                        value={content}
                        onChange={(e) => setContent(e.target.value)}
                        onScroll={handleScroll}
                        onKeyDown={handleKeyDown}
                        onPaste={handlePaste}
                        className="editor-textarea editor-font"
                        spellCheck="false"
                        autoCapitalize="off"
                        autoComplete="off"
                        autoCorrect="off"
                    />
                </div>
            );
        };

        // --- Sidebar Item ---
        const FileListItem = ({ file, isActive, onClick, onClose }) => {
            return (
                <div 
                    onClick={onClick}
                    className={`flex items-center justify-between px-3 py-2 text-sm cursor-pointer border-l-2 transition-colors group
                        ${isActive 
                            ? 'bg-[#37373d] text-white border-blue-500' 
                            : 'bg-transparent text-[#969696] border-transparent hover:bg-[#2a2d2e] hover:text-gray-200'}`}
                >
                    <div className="flex items-center gap-2 overflow-hidden">
                        <span className="opacity-70 text-xs font-mono w-4 flex-shrink-0">
                           {file.language === 'plain' ? 'TXT' : file.language.slice(0,2).toUpperCase()}
                        </span>
                        <span className="truncate">{file.name}</span>
                    </div>
                    <button 
                        onClick={(e) => { e.stopPropagation(); onClose(); }}
                        className={`opacity-0 group-hover:opacity-100 hover:text-white p-1 rounded hover:bg-[#4d4d4d] ${isActive ? 'opacity-100' : ''}`}
                    >
                        <svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
                    </button>
                </div>
            );
        };

        // --- Main App ---
        const App = () => {
            const [files, setFiles] = useState([
                { id: '1', name: 'readme.md', content: '# Fixed Editor V3\n\n- Fixed Auto-scroll on Emacs key navigation', language: 'markdown', lineEnding: 'LF' }
            ]);
            const [activeId, setActiveId] = useState('1');
            const [isSplit, setIsSplit] = useState(false);
            const [msg, setMsg] = useState("");
            const [sidebarWidth, setSidebarWidth] = useState(200);

            const activeFile = files.find(f => f.id === activeId) || files[0];

            const showMessage = (text) => {
                setMsg(text);
                setTimeout(() => setMsg(""), 3000);
            };

            const updateActiveFile = (updatedFile) => {
                setFiles(files.map(f => f.id === updatedFile.id ? updatedFile : f));
            };

            const createNewFile = () => {
                const newId = generateId();
                const newFile = { id: newId, name: 'untitled.txt', content: '', language: 'plain', lineEnding: 'LF' };
                setFiles([...files, newFile]);
                setActiveId(newId);
            };

            const closeFile = (id) => {
                const newFiles = files.filter(f => f.id !== id);
                if (newFiles.length === 0) {
                    const newId = generateId();
                    setFiles([{ id: newId, name: 'untitled.txt', content: '', language: 'plain', lineEnding: 'LF' }]);
                    setActiveId(newId);
                } else {
                    setFiles(newFiles);
                    if (id === activeId) {
                        setActiveId(newFiles[newFiles.length - 1].id);
                    }
                }
            };

            const importFiles = (fileList) => {
                if (!fileList || fileList.length === 0) return;

                Array.from(fileList).forEach(file => {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const raw = e.target.result;
                        const lineEnding = detectLineEnding(raw);
                        const content = raw.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
                        const newFile = {
                            id: generateId(),
                            name: file.name,
                            content,
                            language: detectLanguage(file.name),
                            lineEnding
                        };
                        setFiles(prev => [...prev, newFile]);
                        setActiveId(newFile.id);
                    };
                    reader.readAsText(file);
                });
                showMessage(`${fileList.length} files imported`);
            };

            const handleDownload = () => {
                if (!activeFile) return;
                let raw = activeFile.content;
                if (activeFile.lineEnding === 'CRLF') raw = raw.replace(/\n/g, '\r\n');
                else if (activeFile.lineEnding === 'CR') raw = raw.replace(/\n/g, '\r');

                const blob = new Blob([raw], { type: "text/plain" });
                const url = URL.createObjectURL(blob);
                const a = document.createElement("a");
                a.href = url;
                a.download = activeFile.name;
                a.click();
                URL.revokeObjectURL(url);
                showMessage(`Saved ${activeFile.name}`);
            };

            const handleDrop = (e) => {
                e.preventDefault();
                importFiles(e.dataTransfer.files);
            };

            return (
                <div 
                    className="flex h-screen w-screen bg-[#1e1e1e] text-[#cccccc]" 
                    onDragOver={e => e.preventDefault()} 
                    onDrop={handleDrop}
                >
                    {/* Sidebar */}
                    <aside 
                        className="bg-[#252526] flex flex-col border-r border-[#1e1e1e] flex-shrink-0 relative"
                        style={{ width: sidebarWidth }}
                    >
                        <div className="h-9 px-3 flex items-center justify-between text-xs font-bold text-[#bbbbbb] uppercase tracking-wider bg-[#2d2d2d]">
                            <span>Explorer</span>
                            <div className="flex gap-1">
                                <button onClick={createNewFile} className="hover:text-white" title="New File">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="12" y1="18" x2="12" y2="12"></line><line x1="9" y1="15" x2="15" y2="15"></line></svg>
                                </button>
                                <label className="hover:text-white cursor-pointer" title="Import File">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line></svg>
                                    <input type="file" multiple className="hidden" onChange={e => importFiles(e.target.files)} />
                                </label>
                            </div>
                        </div>
                        
                        <div className="flex-1 overflow-y-auto py-1">
                            {files.map(f => (
                                <FileListItem 
                                    key={f.id} 
                                    file={f} 
                                    isActive={f.id === activeId} 
                                    onClick={() => setActiveId(f.id)}
                                    onClose={() => closeFile(f.id)}
                                />
                            ))}
                        </div>
                    </aside>

                    {/* Main Content */}
                    <div className="flex-1 flex flex-col min-w-0">
                        <header className="h-10 bg-[#2d2d2d] flex items-center justify-between px-4 border-b border-[#1e1e1e]">
                            <div className="flex items-center gap-3 overflow-hidden">
                                {activeFile && (
                                    <>
                                        <input 
                                            type="text" 
                                            value={activeFile.name}
                                            onChange={(e) => updateActiveFile({ ...activeFile, name: e.target.value, language: detectLanguage(e.target.value) })}
                                            className="bg-transparent text-gray-200 text-sm font-medium focus:bg-[#3c3c3c] focus:outline-none px-1 rounded truncate min-w-[50px]"
                                        />
                                        <span className="text-xs text-gray-500 hidden sm:inline">
                                            {activeFile.language} • {activeFile.content.length} chars
                                        </span>
                                    </>
                                )}
                            </div>

                            <div className="flex items-center gap-2">
                                {msg && <span className="text-green-400 text-xs mr-2 animate-pulse">{msg}</span>}
                                
                                {activeFile && (
                                    <>
                                        <div className="flex items-center text-xs bg-[#3c3c3c] rounded border border-[#555] overflow-hidden mr-2">
                                            {['LF', 'CRLF', 'CR'].map(mode => (
                                                <button 
                                                    key={mode}
                                                    onClick={() => updateActiveFile({ ...activeFile, lineEnding: mode })} 
                                                    className={`px-2 py-1 ${activeFile.lineEnding===mode ? 'bg-[#007acc] text-white' : 'text-gray-400 hover:bg-[#4d4d4d]'}`}
                                                >
                                                    {mode}
                                                </button>
                                            ))}
                                        </div>

                                        <button 
                                            onClick={() => setIsSplit(!isSplit)}
                                            className={`p-1.5 rounded transition-colors ${isSplit ? 'bg-[#007acc] text-white' : 'bg-[#3c3c3c] text-gray-300 hover:bg-[#4d4d4d]'}`}
                                            title="Split View"
                                        >
                                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect x="2" y="3" width="20" height="18" rx="2" ry="2"></rect><line x1="12" y1="3" x2="12" y2="21"></line></svg>
                                        </button>

                                        <button 
                                            onClick={handleDownload}
                                            className="bg-green-700 hover:bg-green-600 text-white p-1.5 rounded transition-colors ml-1"
                                            title="Save File"
                                        >
                                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path><polyline points="17 21 17 13 7 13 7 21"></polyline><polyline points="7 3 7 8 15 8"></polyline></svg>
                                        </button>
                                    </>
                                )}
                            </div>
                        </header>

                        <main className="flex-1 flex overflow-hidden relative bg-[#1e1e1e]">
                            {activeFile ? (
                                isSplit ? (
                                    <>
                                        <div className="w-1/2 h-full border-r border-[#333]">
                                            <EditorPane file={activeFile} updateFile={updateActiveFile} />
                                        </div>
                                        <div className="w-1/2 h-full">
                                            <EditorPane file={activeFile} updateFile={updateActiveFile} />
                                        </div>
                                    </>
                                ) : (
                                    <div className="w-full h-full">
                                        <EditorPane file={activeFile} updateFile={updateActiveFile} />
                                    </div>
                                )
                            ) : (
                                <div className="w-full h-full flex items-center justify-center text-gray-500">
                                    No file open
                                </div>
                            )}
                        </main>
                        
                        <footer className="h-6 bg-[#007acc] text-white text-xs flex items-center px-4 justify-between select-none">
                             <div className="flex gap-4">
                                {activeFile && (
                                    <>
                                        <span>Ln {activeFile.content.split('\n').length}</span>
                                        <span>{activeFile.language.toUpperCase()}</span>
                                    </>
                                )}
                            </div>
                            <div className="flex gap-4">
                                <span>UTF-8</span>
                            </div>
                        </footer>
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
